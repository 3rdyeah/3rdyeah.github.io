## 锁

### 锁的 4 种状态

无锁、偏向锁、轻量级锁、重量级锁（低到高）

### 锁升级

**偏向锁的升级**

当一个线程访问代码快并获取锁对象时，会在对像头和栈帧中记录偏向锁的 threadID，以后再有线程获取这个代码快的锁的时候，需要比较当前线程的 threadID 和 java 对像头中的 threadID 是否一致，如果不一致，查看记录中的 threadID 所指的线程是否存活，如果没存活，则锁对象重置为无锁状态，新线程可以竞争上偏向锁；如果仍然存活，则根据该线程栈帧信息判断是否还需要继续持有这个锁，如果需要，则暂停旧线程，撤销偏向锁，升级为轻量锁，如果不需要继续持有该锁，则将锁设置为无所状态并重新偏向新的线程

#### 轻量级锁的升级

### 锁粗化

因为加锁需要消耗资源，如果存在一系列的连续加锁、解锁操作，可能会导致不必要的性能损耗。

锁粗化就是将多个连续的加锁、解锁操作连在一起，扩展成一个更大范围的锁，避免重复的加锁、解锁操作。

### 锁消除

Java 虚拟机 在 JIT 编译时，优化调没有必要的锁，节省无意义的请求锁时间。

### synchronized

> 特性：原子性、可见性、有序性、可重入性

> 实现方式：基于进入和退出 monitor 对象来实现方法同步和代码块同步

### synchronized 和 lock 的区别

- synchronized 是一个关键字，它的实现在 jvm 层面上，而 lock 是一个接口
- synchronized 发生异常时会自动释放锁，而 lock 不会
- synchronized 的锁状态无法判断，lock 可以判断锁状态
- synchronized 不可中断、非公平，lock 可中断、可公平
- synchronzed 适合少量同步，lock 适合大量同步

## 怎么保证消息顺序

使用消息队列，并对消息的收发者使用 hash 分配消息的收发队列，同一个发送者或者接受者只从同一个队列收发消息

## 如果客户端接受服务器返回的消息失败，无限尝试重发消息，怎么处理

在服务器存储一个针对当前客户端的唯一消息 id，客户端初次连接返回给客户端，每次客户端向服务器发送消息都要带上这个唯一 id，每次服务器接到客户端消息后都要更新这个唯一 id 并返回给客户端