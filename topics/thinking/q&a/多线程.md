# 多线程

## 线程状态

- new
- runable
- blocked
- wait
- timed_wait
- terminated

## wait 和 sleep 有什么区别

### 来自不同类

wait -> Object

Sleep -> Thread

### 是否持有锁

wait 会释放锁，恢复时重新申请

sleep 会持有锁，其他线程等待

## Lock（锁）

### 锁的 4 种状态

无锁、偏向锁、轻量级锁、重量级锁（低到高）

### 锁升级

**偏向锁的升级**

当一个线程访问代码快并获取锁对象时，会在对像头和栈帧中记录偏向锁的 threadID，以后再有线程获取这个代码快的锁的时候，需要比较当前线程的 threadID 和 java 对像头中的 threadID 是否一致，如果不一致，查看记录中的 threadID 所指的线程是否存活，如果没存活，则锁对象重置为无锁状态，新线程可以竞争上偏向锁；如果仍然存活，则根据该线程栈帧信息判断是否还需要继续持有这个锁，如果需要，则暂停旧线程，撤销偏向锁，升级为轻量锁，如果不需要继续持有该锁，则将锁设置为无所状态并重新偏向新的线程

#### 轻量级锁的升级

### 锁粗化

因为加锁需要消耗资源，如果存在一系列的连续加锁、解锁操作，可能会导致不必要的性能损耗。

锁粗化就是将多个连续的加锁、解锁操作连在一起，扩展成一个更大范围的锁，避免重复的加锁、解锁操作。

### 锁消除

Java 虚拟机 在 JIT 编译时，优化调没有必要的锁，节省无意义的请求锁时间。

### synchronized

> 特性：原子性、可见性、有序性、可重入性

> 实现方式：基于进入和退出 monitor 对象来实现方法同步和代码块同步

### synchronized 和 lock 的区别

| synchronized               | lock                                 |
| -------------------------- | ------------------------------------ |
| 关键字                     | Java 类                              |
| 无法判断锁状态             | 可以判断锁状态                       |
| 自动释放锁                 | 手动释放锁                           |
| 可重入、不可中断、非公平锁 | 可重入、可判断、可以自己设置是否公平 |
| 适合少量代码               | 适合大量代码                         |

### synchronized

### ReetrantLock

- NonfairSync（默认）：非公平锁，可以插队
- FairSync：公平锁，顺序执行

## 虚假唤醒问题



## ReadWriteLock

readLock 和 writeLock 的阻塞关系

写阻塞读写，读只阻塞写