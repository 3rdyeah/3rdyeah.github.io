+++
title = '第七章 虚拟机类的加载机制.md'
date = 2023-11-09T15:56:46+08:00
draft = true
tags = ['jvm']
+++

# 第七章 虚拟机类的加载机制

## 7.2 类加载的时机

类在虚拟机中的生命周期：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）、卸载（Unloading）。其中验证、准备、解析 3 个部分统称为连接（Linking），具体如下图所示：

![7.1 class_life_cycle_p-Simple.png](https://github.com/3rdyeah/3rdpics/blob/master/picbed/7.1%20class_life_cycle_p-Simple.png?raw=true)

<center>图 7.1 类的生命周期</center>

加载、验证、准备、初始化、卸载这 5 个阶段的顺序时确定的，类的加载过程中必须按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这为了支持 Java 语言的运行时绑定（动态绑定或晚期绑定）。注意这里说的时“开始”而不是“进行”或“完成”，因为某些阶段通常会在执行过程中调用、激活另一个阶段，而不是这个阶段全部完成后才开始下一个阶段，他们时交叉混合式的进行的。

虚拟机规范严格规定了有且只有 5 种情况会立即对类进行“初始化”：

1. 遇到 new、getstatic、putstatic 或 invokestatic 这四条字节码指令时触发类的初始化。常见场景：使用 new 关键字实例化对象、读取或设置一个类的静态字段（被 final 修饰、已在编译器把结果放入常量池的静态字段除外）、调用一个类的静态方法的时候。
2. 使用 java.lang.reflect 包的方法对类进行反射调用时。
3. 初始化一个类时，如果发现父类没有初始化，那么先初始化父类。
4. 虚拟机启动时，需要先初始化主类（包含 main() 方法的那个类）
5. 当使用 JDK1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个句柄所对应的类没有进行过初始化，先触发其初始化。

以上 5 种是“有且只有”的会触发类初始化的场景，这 5 种行为被称为对一个类的主动引用。除此之外的所有引用类的方法都不会触发初始化，称为被动引用。

举里说明 3 种被动引用：

代码清单 7-1 被动引用例一

```java
package org.fenixsoft.classloading;

public class SuperClass {
    static {
        System.out.println("SuperClass init!");
    }
}

public class SubClass extends SuperClass {
    static {
        System.out.println("SubClass init!");
    }
}
```

```java
package org.fenixsoft.classloading;
//非主动使用类字段
public class NotInitialization1 {
    public static void main(String[] args) {
        System.out.println(SubClass.value);
    }
}
```

上面的 main 方法运行后，只会输出“SuperClass init!”。对于静态字段，只有直接定义这个字段的类会被初始化，通过子类来引用父类中定义的静态字段只会触发父类的初始化。至于是否触发子类的加载和验证取决于虚拟机的具体体现，Sun HotSpot 虚拟机可以通过 -XX:+TraceClassLoading 参数观察子类是否加载。

代码清单 7-2 被动引用例二

```java
package org.fenixsoft.classloading;
//通过数组定义来引用类，不会触发此类初始化
public class NotInitialization2 {
    public static void main(String[] args) {
        SuperClass[] sca = new SuperClass[10];
    }
}
```

这里不会输出“SuperClass init!”，说明没有触发 SuperClass 的初始化。但是这段代码里触发了另一个名为“Lorg.fenixsoft.classloading.SuperClass”的类的初始化，对于用户代码来说，这并不是一个合法的类名称，它是一个由虚拟机自动生成的、直接继承自 Object 类的子类，创建动作由字节码指令 newarray 触发。

这个类代表了一个元素类型为 org.fenixsoft.classloading.SuperClass 的一维数组，数组中应有的属性和方法都在这个类实现，但用户可以直接使用的只有被修饰为 public 的 length 属性和 clone() 方法。Java 对数组的访问比 C/C++ 安全就是因为这个类封装了数组元素的访问方法，而 C/C++ 是直接移动数组指针。在 Java 中，数组越界会抛出 java.lang.ArrayIndexOutOfBoundsException 异常。

代码清单 7-3 被动引用例三

```java
package org.fenixsoft.classloading;

public class ConstClass {
    static {
        System.out.println("ConstClass init!");
    }
    public static final String HELLOWORLD = "hello world";
}

public class NotInitialization3 {
    public static void main(String[] args) {
        System.out.println(ConstClass.HELLOWORLD);
    }
}
```

运行上述代码并不会输出"ConstClass init!"，因为 HELLOWORLD 作为一个常量在编译期就已经被存储到了 NotInitialization 类的常量池中，所以调用的时候也只是 NotInitialization 对自身常量池的引用，所以并不会初始化 ConstClass 类。

接口的加载过程与类加载过程稍有不同：接口和类一样也有初始化过程，接口不能像上面的代码一样使用静态语句块“static{}”来输出初始化信息，但编译器仍然会为接口生成“<clinit>()”类构造器用于初始化接口定义的成员变量。接口与类的真正区别是前面主动引用的第 3 种：初始化一个类时要求先初始化其所有父类，但接口在初始化时，并不要求先初始化其父类，只有用到父类接口时才初始化。

## 7.3 类加载的过程

### 7.3.1 加载

在加载阶段，虚拟机需要完成 3 件事：

1. 通过一个类的全限定名来获取定义此类的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化为方法去的运行时数据结构。
3. 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。

以上 3 点要求其实并不具体，因此增加了虚拟机实现与具体应用的灵活度。比如第 1 条中并没有具体指明这个字节流要从哪里、怎样获取。所以这个加载阶段的平台相当开放，比如：

- 从 zip 包中读取，最终形成了 jar、ear、war 等格式。

- 从网络中获取，applet 就是典型应用。

- 运行时计算生成，这种场景使用的最多的就是动态代理技术，在 java.lang.reflect.Proxy 中，就是用了 ProxyGenrator.generateProxyClass 来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。

- 由其他文件生成，典型场景时 JSP 应用，即由 JSP 文件生成对应的 Class 类。
- 从数据库读取，这种场景比较少见。

相对于类加载的其他阶段，一个非数组类的加载阶段是开发人员可控性最强的，我们既可以使用系统提供的引导类加载器来完成，也可以自定义类加载器来完成，开发人员可以通过自定义类加载器取控制字节流的获取方式（通过重写类加载器的 loadClass() 方法）。

数组类则不同，数组类本身不通过类加载器创建，它是由 Java 虚拟机直接创建的。但数组类与类加载器任然有密切关系，因为数组类的元素类型（Element Type，数组去掉所有维度的类型）最终是要靠类加载器取创建，一个数组类的创建过程就遵循以下过程：

如果数组的组件类型（Component Type，数组去掉一个维度的类型）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组将在加载该组件类型的类加载器的类名称空间上被标识（一个类必须与类加载器一起确定唯一性）。

如果数组的组件类型不是引用类型（例如 int[]），Java 虚拟机将会把数组标记为与引导类加载器关联。

[^]: 个人理解：也就是说一个数组类的加载器只与它去掉一个维度之后的组件类型有关，如果是多维数组，那么去掉一个维度之后的组件类型还会再去掉一个维度然后去关联加载器

数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为 public。

加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法去中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范中没有规定此区域的具体数据结构。

然后在内存中实例化一个 java.lang.Class 类的对象（在 HotSpot 虚拟机中，这个对象存放在方法区），这个对象将作为程序访问方法去中的这些类型数据的外部接口。

加载阶段与连接阶段的部分内容是交叉进行的，比如一部分字节码文件格式的验证动作，可能在加载阶段尚未完成，连接阶段可能已经开始，但是这些夹在加载阶段的动作仍然属于连接阶段，这两个阶段的开始时间仍然保持着固定的先后顺序。

### 7.3.2 验证

验证是连接阶段的第一步，主要是为了确保 Class 文件的字节刘中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全。

Java 语言本身是相对安全的，存粹的 Java 代码无法做到诸如访问数组边界外的数据、将一个对象转型为它并未实现的类型、跳转到不存在的代码行之类的事情，如果这样做了，编译器将拒绝编译。但因为 Class 文件并不一定用 Java 源码编译而来，它可能来自任何途径，包括使用十六进制编辑器直接编写。在字节码语言层面上，上述 Java 代码无法实现的事情都可能被实现。所以虚拟机需要对输入的字节流进行检查，避免有害的字节流导致系统崩溃，以保证虚拟机自身的安全。

如果验证到输入的字节流不符合 Class 文件格式的约束，虚拟机就应抛出一个 Java.lang.VerifyError 异常 或其他子类异常，但直到 2011 年发布的《Java 虚拟机规范（Java SE 7 版）》之前，虚拟机规范对这个验证阶段的约束和规则都很笼统，在这之后才具体起来。从整体上看，验证阶段打之会完成下面 4 个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。

1. 文件格式验证

   验证字节流是否符合 Class 文件格式规范，并能并当前版本虚拟机处理。可能包括一下验证点：

   - 是否以魔数 0xCAFEBABE 开头
   - 主次版本号是否在当前虚拟机处理范围内
   - 常量池的常量中是否存在不支持的常量类型（检查常量 tag 标志）
   - 指向常量的各种索引值中是否由指向不存在的常量或者不符合类型的常量
   - CONSTANT_Utf8_info 型的常量中是否有不符合 UTF8 编码的数据
   - Class 文件中各个部分及文件本身是否有被删除的或附加的其他信息
   - ……

   诸如此类的验证点还有很多，这个阶段的验证基于二进制字节流，只有通过这个阶段的验证，字节流才会进入内存的方法去中进行存储，也意味着后面的 3 个验证阶段全部基于方法去的存储结构，不再直接操作字节流。

2. 元数据验证

   对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求：

   - 是否有父类（除 Object 类意外）

   - 父类是否继承了被允许被继承的类（被 final 修饰的类）

   - 如果该类不是抽象类，是否实现了所有必须实现的方法（来自父类和接口的发给发）

   - 字段、方法是否与父类产生矛盾（覆盖父类的 final 字段、方法重载不符合规则等）

   - ###### ……

3. 字节码验证

   这个阶段最复杂，主要是通过数据流和控制流分析，确定程序意义是合法的、符合逻辑的。在上个阶段校验完数据类型后，这个阶段将对类的方法体进行校验分析，以保证被校验类的方法在运行时不会做出危害虚拟机安全的事件，例如：

   - 保证任何时刻操作数栈的数据类型与指令代码序列都能配合工作，比如用 long 类型的字节码指令来载入操作栈中 int 类型的数据
   - 保证跳转指令不会跳转到方法体意外的字节码指令上
   - 保证方法体中的类型转换有效，比如我们可以把子类对象赋值给父类类型，但反过来甚至赋值给一个预期毫无关系的数据类型就是不允许的
   - ……

4. 符号引用验证

   最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三个阶段——解析阶段中发生。符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，通常包括：

   - 通过字符串描述的全限定名是否能找到对应类
   - 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段
   - 符号引用中的类、字段、方法的访问性（私有、保护、共有、默认）是否可以被当前类访问。
   - ……

   符号引用验证的目的在于保证解析动作能够正常执行，无法通过符号引用验证时虚拟机会抛出 java.lang.IncompatibleClassChangeError 异常的子类。

### 7.3.3 准备

准备阶段时正式为类变量分配内存并设置类变量<font color="red">初始值</font>的阶段，这些变量所使用的内存都将在方法去中进行分配。这个阶段有两个容易产生混淆的的概念，首先，这时候进行内存分配的仅包括类变量（被 static 修饰的变量），不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。其次，这里所说的初始值“通常情况”下时数据类型的凌志，假设一个类变量定义为：

```java
public static int value = 123;
```

那变量 value 在准备阶段过后的初始值为 0 而不是 123，因为这个时候尚未开始执行任何 Java 方法，而把 value 赋值为 123 的 putstatic 指令实在程序被编译后，存放与类构造器 <clinit>() 方法之中，所以把 value 赋值为 123 的动作将在初始化阶段才会执行。

<center>表 7-1 基本数据类型的零值</center>

| 类型 | int  | long |  short   |   char   |  byte   | boolean | float | double | reference |
| ---- | :--: | :--: | :------: | :------: | :-----: | :-----: | :---: | :----: | :-------: |
| 零值 |  0   |  0L  | (short)0 | '\u0000' | (byte)0 |  false  | 0.0f  |  0.0d  |   null    |

上面提到，在“通常情况”下初始值时零值，那相对的会有一些“特殊情况”：如果类字段的字段属性表中存在 ConstantValue 属性，那在准备阶段变量值就会被初始化为 ContantValue 属性所指定的值，如

```java
public static final int value = 123;
```

编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 123。

### 7.3.4 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。而且各虚拟机的内存布局实现可能并不相同，但符号引用的定义必须是一致的，这个明确定义在 Java 虚拟机规范的 Class 文件格式中。

直接引用（Direct References）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用和虚拟机实现的内存布局相关，所以在不同的虚拟机上同一个符号引用翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。

虚拟机规范并未规定解析阶段的具体时间，只要求在执行 16 个操作符号引用的字节码指令之前对符号引用进行解析。至于实在类被加载器加载时就对常量池中的符号引用进行解析还是等到一个符号引用将要被使用前才去解析，取决于虚拟机自己的实现。

16 个操作符号引用的字节码包括：

anewarray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、ldc、ldc_w、multianewarray、new、putfield、putstatic

对同一个符号引用进行多次解析请求是很常见的，除 invokedynamic 指令之外，虚拟机实现可以对第一次解析的结果进行缓存从而避免重复解析。

虚拟机需要保证在同一个实体中，除 invokedynamic 指令之外，如果一个符号引用之前已经被成功解析过，那么后续的解析请求也应当一直成功；繁殖，如果第一次解析失败了，那么其他指令对这个符号的解析请求也应当收到相同的异常。

invokedynamic 指令的本来目的就是用于动态语言支持，它所对应的引用称为“动态调用点限定符”（Dynamic Call Site Specifier），这里“动态”的含义就是必须等到程序实际运行到这条指令的时候才能进行解析。

解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行，和常量池的常量类型对应如下图所示：

| 符号引用类型 | 常量类型                         |
| ------------ | -------------------------------- |
| 类或接口     | CONSTANT_Class_info              |
| 字段         | CONSTANT_Fieldref_info           |
| 类方法       | CONSTANT_Methodref_info          |
| 接口方法     | CONSTANT_InterfaceMethodref_info |
| 方法类型     | CONSTANT_MethodType_info         |
| 方法句柄     | CONSTANT_MethodHandle_info       |
| 调用点限定符 | CONSTANT_InvokeDynamic_info      |

## 7.4 类加载器

虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。

类加载器在类层次划分、OSGi、热部署、代码加密等领域大放异彩，是 Java 技术体系中一块重要的基石。

### 7.4.1 类与类加载器

类加载器虽然只用于实现类的加载动作，但它在 Java 程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器都有其独立的类命名空间。更通俗的表达方式是：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，不同类加载器即使加载同一个 Class 文件，得到的类也必定不相等。

这里所指的“相等”，包括代表类的 Class 对象的 equal() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果，也包括使用 instanceof 关键字做对象所属关系判定等情况。

### 7.4.2 双亲委派模型

从 Java 虚拟机角度来看，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，由 Java 实现，独立于虚拟机外部，并且全部继承自抽象类 java.lang.ClassLoader。

从开发人员的角度来看，类加载器还可以划分得更细致一些，觉得部分 Java 程序都会用到以下 3 种系统提供的类加载器。

启动类加载器（Bootstrap ClassLoader）：这个类加载器负责将存放在 <JAVA_HOME>\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，那直接使用 null 代替即可。

扩展类加载器（Extension ClassLoader）：这个类加载器由 sun.misc.Launcher $ExtClassLoader 实现，它负责加载<JAVA_HOME>\lib\ext 目录中的，或者被 java.ext.dirs 系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。

应用程序类加载器（Application ClassLoader）：这个类加载器由 sun.misc.Launcher $App-ClassLoader 实现。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，所以一般也称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中的默认类加载器。

我们的应用程序都是由这 3 中类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。这些类加载器之间的关系一般如图 7-2 所示。

![7.2 classloader_parents_delegation_model](https://raw.githubusercontent.com/3rdyeah/3rdpics/master/picbed/7.2%20classloader_parents_delegation_model.png)

<center>图 7-2 类加载器双亲委派模型</center>

双亲委派模型要求，除了顶层的启动类加载器外，其余的类加载器都应当有自己的父加载器，但这里的父子关系一般都是以组合而不是继承的关系来实现，也就是说，子类加载器会先使用父类加载器，父类加载器无法加载时再调用自身去加载类。当然这并不是一个强制要求，而是 Java 设计者推荐给开发者的一种类加载器实现方式。

双亲委派模型的工作过程是：

1. 一个类加载器收到类加载请求
2. 尝试将类加载请求委派给父类加载器去加载，父类加载器再委派给父类的父类，层层向上委派
3. 父类加载器可以加载则由父类加载器加载，否则交给子类加载器自己加载。

### 7.4.3 破坏双亲委派模型

上面说过双亲委派模型不是强制要求，只是被 Java 设计者推荐使用。通常大部分 Java 类加载器都遵循这个要求，但到目前为止，双亲委派模型经历过 3 次较大规模的“被破坏”。

第一次“被破坏”其实发生在双亲委派模型出现之前，即——JDK 1.2 发布之前。由于类加载器和抽象类 java.lang.ClassLoader 在 JDK 1.0 时代就已存在，所以面对已经存在的用户自定义的类加载器的实现代码，Java 设计者做了一些妥协，在 JDK 1.2 之后再 java.lang.ClassLoader 类中加了一个新的 protected 的方法 findClass()，在此之前，用户继承 java.lang.ClassLoader 的唯一目的是为了重写 loadClass() 方法，JDK 1.2 之后就不再提倡将代码卸载 loadClass() 方法中，而是在 findClass() 方法中实现自己的逻辑，这样写出来的代码就符合双亲委派模型了。

第二次和第三次“被破坏”可以去搜索 JNDI 和 OSGi 的相关信息。