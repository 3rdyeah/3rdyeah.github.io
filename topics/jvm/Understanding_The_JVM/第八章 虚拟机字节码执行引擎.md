# 第八章 虚拟机字节码执行引擎

代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，确实编程语言发展的一大步。

## 8.1 概述

执行引擎是 Java 虚拟机最核心的组成部分之一。“虚拟机”是一个相对于“物理机”的概念，两者都有代码执行能力，区别是物理机的执行引擎是直接建立在处理器、硬件、指令集上和操作系统上的，而虚拟机的执行引擎是由自己实现的，因此可以自行定义指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。

在 Java 虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，这个概念模型称为各种虚拟机执行引擎的统一外观（Facede）。在不同的虚拟机实现里面，执行引擎在执行 Java 代码的时候可能会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择，也可能两者兼备，甚至还可能会包含几个不同级别的编译器执行引擎。但从外观来看，所有的 Java 虚拟机的执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果，本章将主要从概念模型的角度来讲解虚拟机的方法调用和字节码执行。

## 8.2 运行时栈帧结构

栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。

每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并写入到方法表的 Code 属性值中，因此一个栈桢需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。

一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态。对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧（Current Stack Frame），与这个栈帧相关的方法称为当前方法（Current Method）。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作，在概念模型上，典型的栈帧结构如图 8-1 所示。

![stack_frame_struct](https://raw.githubusercontent.com/3rdyeah/3rdpics/master/picbed/stack_frame_struct.png)

<center>图 8-1 栈帧的概念结构</center>

### 8.2.1 局部变量表

局部变量表（Local Variable Table）是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在 Java 程序编译为 Class 文件时，就在方法的 Code 属性的 max_locals 数据项中确定了该方法所需要分配的局部变量表的最大容量。

局部变量表的容量以变量槽（Variable Slot，下称 Slot）为最小单位，虚拟机规范中并没有明确指明一个 Slot 应占用的内存大小，只是很有导向性地说明每个 Slot 都应该能存放一个 boolean、byte、char、short、int、float、reference 或 returnAddress 类型地数据，这八种数据都可以使用 32 位或更小地物理内存来存放，但这种描述与明确指出“每个 Slot 占用 32 位长度的内存空间”是有一些差别的，它允许 Slot 的长度可以随着处理器、操作系统或虚拟机的不同而发生变化。只要保证即使在 64 位虚拟机中使用了 64 位的物理内存空间去实现一个 Slot，虚拟机仍要使用对齐和补白的手段让 Slot 在外观上看起来与 32 位虚拟机中的一致。

一个 Slot 可以存放一个 32 位以内的数据类型，Java 中占用 32 位以内的数据类型有 boolean、byte、char、short、int、float、reference 和 returnAddress 8 种类型。除前 6 种外，reference 类型表示对一个对象的实例的引用，虚拟机贵方没有说明它的长度，也没有明确指出它的结构，但一般来说，虚拟机至少都应当能通过引用做到两点，一是从此引用中直接或间接地查找到对象在 Java 堆种地数据存放的起始地址索引，而是此引用种直接或间接地查找到对象所属数据类型在方法区种地存储地类型信息，否则无法实现 Java 语言规范中定义地语法约束。至于 returnAddress 类型目前已经很少见了，它是为字节码指令 jsr、jsr_w 和 ret 服务的，指向一条字节码指令地地址，很古老地 Java 虚拟机曾经使用这几条指令来实现异常处理，现在已经由异常表代替。

对于 64 位的数据类型，虚拟机会以高位对齐的方式为其分配两个连续的 Slot 空间。Java 语言中明确的（reference 类型则即可能是 32 位也可能是 64 位）64 位类型只有 long 和 double 两种。这里把 long 和 double 数据类型分割存储的做法与“long 和 double 的非原子性协定”中把一次 long 和 double 数据类型读写分割为 32 位读写的做法有些类似。不过由于局部变量表建立在线程的堆栈上，是线程私有数据，无论读写两个连续的 Slot 是否原子操作，都不会引起数据安全问题。

虚拟机通过索引定位的方式使用局部变量表，索引值的范围时从 0 开始至局部变量表的最大 Slot 数量。如果访问的时 32 位数据类型的变量，索引 n 就代表了使用第 n 个 Slot，如果时 64 位数据类型的标量，则说明会同时使用 n 和 n+1 两个 Slot。对于两个相邻的共同存放一个 64 位数据的两个 Slot，不允许采用任何方式单独访问其中某一个，Java 虚拟机规范中明确要求了如果遇到进行这种操作的字节码序列，虚拟机应该在类加载的校验阶段抛出异常。

方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果执行的是实例方法（非 static 的方法），那局部变量表中第 0 位索引的 Slot 默认时用于传递方法所属对象实例的引用，在方法中可以通过关键字 this 来访问到这个隐含的参数，参数表分配完毕后，在根据方法内部定义的变量顺序和作用域分配其余的 Slot。

为了尽可能节省栈帧空间，局部变量表中的 Slot 是可以重用的，方法体中定义的变量，其作用域不一定会覆盖整个方法体，如果当前字节码 PC 计数器的值已经超出了某个变量的作用域，那这个变量对应的 Slot 就可以交给其他变量使用。不过这样的设计也有一些副作用，比如在某些情况下，Slot 的复用会直接影响到系统的垃圾回收行为，这里举例说明。

在《 Practical Java》中有一条推荐的编码规则，即“不使用的对象应手动赋值为 null”，书中并没有解释原因，这里我们可以从从栈帧的角度分析一二。

```java
// 代码-1
public static void main(String[] args) {
    byte[] placeholder = new byte[64*1024*1024];
    System.gc();
}
```

```java
// 代码-2
public static void main(String[] args) {
    {
        byte[] placeholder = new byte[64*1024*1024];
    }
    System.gc();
}
```

```java
// 代码-3
public static void main(String[] args) {
    {
        byte[] placeholder = new byte[64*1024*1024];
    }
    int a = 0;
    System.gc();
}
```

上面三段代码很简单，都是分配了 64M 的内存，然后调用系统的垃圾回收来回收它。

区别是代码-2 中将分配操作放在单独的作用域中，代码-3 则是除了划分了单独的作用域，还多定义了一个变量 a。

最终的结果是，代码-1 和代码-2 的内存没有被回收，只有代码-3 的 placeholder 被回收了。

这是因为前两段代码中，placeholder 分配内存后，程序没有任何读写局部变量表的操作，placeholder 所占用的 Solt 没有被其他变量复用，作为 GC Root 一部分的局部变量表仍然保持着和 placeholder 的关联，所以将其回收。而代码-3 中新定义了一个变量 a，复用了 placeholder 所在的 Slot，导致 placeholder 被回收成功，这里对变量 a 的定义可以是任意可以复用 placeholder 所在 Slot 的操作，当然也包括将 placeholder 赋值为 null。



### 8.2.4 方法返回地址

当一个方法开始执行后，只有两种方式可以退出这个方法。

1. 正常完成出口（Normal Method Invocation Completion）：执行引擎遇到任意一个方法返回的字节码指令，此时可能会有返回值传递给上层调用者，是否有返回值和返回值的类型根据遇到何种方法返回指令来决定。
2. 异常完成出口（Abrupt Method Invocation Completion）：方法执行过程中遇到异常且无法在方法内部处理，无论是 Java 虚拟机内部产生的还是代码中 athrow 字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，且不会给上层调用者返回任何返回值。

无论上面哪种方法退出方式，方法退出后，都需要返回方法被调用的位置，程序才能继续执行，方法返回时需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态，方法正常退出时，调用者的 PC 计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址需要通过异常处理器表来确定，栈帧中一般不会保存这部分信息。

方法退出的过程实际上等于把当前栈帧出栈，因此退出时执行的操作可能有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有）压入调用者的操作数栈中，调整 PC 计数器的值以指向方法调用指令后面的一条指令等。

## 8.3 方法调用

### 8.3.1 解析

解析成立的前提：方法在程序真正运行之前就有一个可确定的调用版本，且这个方法的调用版本在运行其是不可改变的。换句话说，调用目标在程序代码写好、编译器进行编译时就必须定下来。这类方法的调用称为解析（Resolution）。

Java 中符合“编译器可知，运行期不可变”这个要求的方法，主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了他们都不可能通过继承或别的方式重写其他版本，因此他们都适合在类加载阶段进行解析。

Java 虚拟机中 5 条方法调用字节码指令：

- invokestatic：调用静态方法。
- invokespecial：调用实例构造器<init>方法、私有方法和父类方法。
- invokevirtual：调用所有的虚方法。
- invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象。
- invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，再执行该方法。

前 4 条调用指令的分派逻辑是固化在 Java 虚拟机内部的，而 invokedynamic 指令的分派逻辑是由用户所设定的引导方法决定的。