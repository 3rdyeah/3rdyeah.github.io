+++
title = '第二章 自动内存管理机制.md'
date = 2023-11-09T15:56:46+08:00
draft = true
tags = ['jvm']
+++

# 第二章 自动内存管理机制

## 2.2 运行时数据区域

Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分位若干个不同的数据区域。这些区域的用途、创建时间和销毁时间各不相同。

![runtime_data_area](https://raw.githubusercontent.com/3rdyeah/3rdpics/master/picbed/runtime_data_area.png)

### 2.2.1 程序计数器

程序计数器是一块较小的内存空间，可以看作**当前线程**所执行的字节码的行号指示器。在 Java 虚拟机的概念模型里，字节码解释器工作时通过改变程序计数器的值来选取下一条需要执行的指令，它是程序控制流的指示器，程序中各种流程的控制都需要依赖这个计数器来完成。

为了多线程的每个线程切换后都能恢复到正确的执行位置，每条线程都会有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称之为“线程私有”的内存。

如果线程正在实行一个 Java 方法，这个计数器记录的就是正在执行的虚拟机字节码指令的地址；如果正在执行的是一个本地（Native）方法，这个计数器的值则位空（Undefined）。此内存区域是唯一一个在《Java 虚拟机会犯》中没有规定任何 OutOfMemoryError 的区域。

### 2.2.2 Java 虚拟机栈

Java 虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是 Java 方法执行的线程内存模型：每个方法被执行的时候，Java 虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

在《Java 虚拟机规范》中，对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverFlowError 异常；如果 Java 虚拟机栈容量可以动态扩展，档栈扩展时无法申请到足够的内存会抛出 OutOfMemoryError 异常。

### 2.2.3 本地方法栈

本地方法栈与虚拟机栈的作用非常相似，区别只在于虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机执行本地（Native）方法服务。

《Java 虚拟机规范》对本地方法栈如何实现没有强制规定，甚至有的 Java 虚拟机（比如 HotSpot）就直接将之与虚拟机栈合二为一。本地方法栈的异常规定则和虚拟机栈相同。

### 2.2.4 Java 堆

Java 堆是虚拟机所管理的内存中最大的一块。Java 堆被所有线程共享，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java 中“几乎”所有的对象实例都在这里分配内存。虽然《Java 虚拟机规范》中要求“所有的对象实例以及数组都应当在对上分配”，但随着 Java 语言的发展，现在已经可以看到些许迹象表明以后可能出现值类型的支持，而且由于编译技术的进步，尤其是逃逸分析技术的日渐强大，站上分配、标量替换优化手段已经导致一些微妙的变化悄然发生，所以说 Java 对象实例都分配在堆上也渐渐变得不是那么绝对了。

根据《Java 虚拟机规范》规定，Java 堆可以处于物理上不连续的内存空间中，但再逻辑上它们应该被视为连续，如同我们用磁盘空间存储文件，并不要求每个文件都连续存放。但对于大对象（典型的如数组对象），多数虚拟机出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。

Java 堆既可以被是现成固定大小，也可以是可扩展的，当前主流的 Java 虚拟机都是按照可扩展来实现的（通过 -Xmx 和 -Xms 来设定）。如果 Java 堆中没有内存来完成实例分配，并且堆也无法再扩展时，会抛出 OutOfMemoryError 异常。

### 2.2.5 方法区

方法区与 Java 堆一样，是所有线程共享的，它用于存储被虚拟机加载的类型信息、常量、静态变量、即使编译器编译后的代码缓存等数据。虽然《Java 虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却又一个别名叫做“非堆”（Non-Heap），目的是与 Java 堆区分开来。

很多人习惯把方法区称呼为“永久代”，但本质上两者并不等价，只是因为在 JDK 8 之前，HotSpot 虚拟机设计团队把是用户去的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得 HotSpot 的垃圾收集器能够像管理 Java 堆一样管理这部分内存，就不用为方法区编写内存管理的代码。但是很多其他虚拟机是不存在永久代这个概念的。在 JDK 7 时，HotSpot 将原本放在永久代的字符串常量池、静态变量移出，而在 JDK 8 之后，HotSpot 完全放弃了永久代的概念，而改用元空间来替代了，把 JDK 7 中还在永久代中的内容（主要是类型信息）放到了元空间中。

相对而言，垃圾回收在方法区中的确比较少出现了，但并非进入了方法区就永远不会被回收了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说，这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时候又确实有必要。之前 HotSpot 的一些严重 Bug 就是由于对此区域未完全回收而导致了内存泄漏。

《Java 虚拟机规范》规定，如果方法区无法满足新的内存分配需求，需要抛出 OutOfMemoryError 异常。

### 2.2.6 运行时常量池

运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放在方法区的运行时常量池中。

运行时常量池相对于 Class 文件常量池的另外一个重要特征是具备动态性，并非预置入 Class 文件中常量池的内容才能进入方法区的运行时常量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用的比较多的便是 String 类的 intern() 方法。

既然是方法区的一部分，自然收到方法区内存的限制，当常量池无法申请到内存时会抛出 OutOfMemoryError 异常。

### 2.2.7 直接内存

直接内存（Derict Memory）并非虚拟机运行时数据区的一部分，也不是《Java 虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现。

JDK 1.4 中加入了 NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里面的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。

显然，本机直接内存不会收到 Java 堆大小的限制，但是既然时内存，则肯定还是会受到本机总内存大小以及处理器寻址空间的限制，如果在设置虚拟机内存时忽略了直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），就会导致动态扩展时出现 OutOfMemoryError 异常。

## 2.3 HotSpot 虚拟机对象探秘

