+++
title = '第三章 垃圾收集器与内存分配策略.md'
date = 2023-11-09T15:56:46+08:00
draft = true
tags = ['jvm']
+++

# 第三章 垃圾收集器与内存分配策略

## 3.1 概述

垃圾收集（Garbage Clooection，GC）需要完成的 3 件事情：

- 那些内存需要回收？
- 什么时候回收？
- 如何回收？

目前内存的动态分配和内存回收技术已经相当成熟，为什么我们还要了解 GC 和内存分配？原因是：档需要排查各种内存溢出、泄露问题时，档垃圾收集成为系统达到更高并发量的瓶颈时，我们需要对这些“自动化”的技术实施必要的监控和调节。



## 3.2 对象已死？

### 3.2.1 引用计数法

### 3.2.2 可达性分析算法

通过一系列称为“GC Roots”的根对象作为起始节点集，从这些结点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果对象到 GC Roots 间没有任何引用链相连，或者用图论的话来说就是从 CG Roots 到这个对象不可达时，则证明此对象时不可能再被使用的。

在 Java 技术体系中，固定可作为 GC Roots 对象包括：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中 JNI（Native 方法） 引用的对象。
- Java 虚拟机内部的引用，如基本数据类型对象的 Class 对象、常驻异常对象、系统类加载器等。
- 所有被同步锁（synchronized 关键字）持有的对象。
- 反应 Java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。

除此之外也有一些其他的对象“临时性”地加入，构成完整的 GC Roots 集合。

### 3.2.3 再谈引用

JDK 1.2 之前引用的定义：如果 reference 类型的的数据中存储的数值代表的时另外一块内存的起始地址，就称该 reference 数据是代表了某块内存、某个对象的引用。

JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为以下几种：

- **强引用（Strongly Reference）**，是最传统的引用，是指在程序代码中普遍存在的引用赋值，类似“Object obj = new Object()”这种引用关系。无论任何情况下只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。
- **软引用（Soft Reference）**，用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。
- **弱引用（Weak Reference）**，也是用来描述非必需对象的，但是它的强度比软引用还要更弱一些，被弱引用关联的对象只能生存道下一次垃圾收集发生为止。无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
- **虚引用（Phantom Reference）**，也称为“幽灵引用”或者“幻影引用”，是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个实例对象。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被回收时收到一个系统提示。

### 3.2.4 生存还是死亡

要真正宣告一个对象的死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件时此对象是否有必要执行 finalize() 方法。加入对象没有覆盖 finalize() 方法，或者 finalize() 方法已经执行过了，那么虚拟机将这两种情况都视为“没有必要执行”。

虽然 Java 提供了 finalize() 方法，但是它的运行代价高昂，不确定性大，无法保证每个对象的调用顺序，所以已经被官方明确声明为补推荐使用的语法。finalize() 方法能做的所有事情，使用 try-finally 或者其他方法都可以做的更好更及时，所以建议你忘掉这个方法。

### 3.2.5 回收方法区

有些人认为方法区是没有垃圾回收行为的，《Java 虚拟机规范》中也提到过可以不要求虚拟机在方法区中实现垃圾收集，事实上也确实有一些收集器未实现或者未完全实现方法区类型的卸载，方法区垃圾收集的“性价比”通常也比较低，因为它很苛刻的判定条件。

方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。

回收废弃的常量与回收 Java 堆中的对象非常类似。

判定一个类型是否属于“不再被使用的类”需要同时满足下面三个条件：

- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例。
- 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的中加载等，否则通常是很难达成的。
- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

## 3.3 垃圾收集算法

从如何判定对象消亡的角度出发，垃圾手机算法可以划分为“引用计数是垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracing GC）两大类，也常被称为“直接垃圾手机”和“简介垃圾收集”。

### 3.3.1 分代收集理论

分代收集理论建立在两个分代假说上：

1. **弱分代假说（Weak Generational Hypothesis）**：绝大多数对象都是朝生夕灭的。
2. **强分代假说（Strong Generational Hypothesis）**：熬过越多次垃圾收集过程的对象就越难以消亡。

这两个假说共同奠定了多款常用的垃圾收集器的一致设计原则：收集器应该将 Java 堆划分出不同区域，然后将回收的对象依据其年龄分配到不同的区域之中存储。

在 Java 堆划分出不同的区域之后，垃圾收集器才可以每次只回收某一个或者某些部分的区域——因而才有了“Minor GC” “Major GC” “Full GC”这样的回收类型的划分；才能够针对不同区域安排与其存储对象消亡特征相匹配的垃圾收集算法——因而发展出了“标记-复制” “标记-清除” “标记-整理”等针对行的垃圾收集算法。

但是分代收集理论也至少存在一个明显的困难：对象不是鼓励的，对象之间会存在跨代引用。针对跨代引用的问题，在原有的分代收集理论上添加了第三条经验法则：

3. **跨代引用假说（Intergenerational Reference Hypothesis）**：跨代引用相对于同代引用来说仅占极少数。

互相存在引用关系的两个对象，是应该倾向于同时生存或者同时灭亡的，即使存在跨代引用，现在存在与新生代的对象也会随着年龄的增长最终晋升到老年代中，跨代引用也随即消除了。

根据第三条假说，我们在新生代上设计了一个全局的数据结构——“记忆集”（Remembered Set），这个结构把老年代划分成若干小块，表示出老年代的哪一块内存会存在跨代引用。在此后发生 Minor GC 时，只有包含了跨代引用的小块内存里的对象才会被加入到 GC Roots 进行扫描。这样做虽然增加了维护记录的复杂度和一些运行时开销，但相比扫描整个老年代来说仍然划算。

### 3.3.2 标记-清除算法

早在 1960 年由 Lisp 之父 John McCarthy 提出的 “标记-清除”（Mark-Sweep）算法是最早出现也是最基础的 GC 算法。算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，然后统一回收掉所有被标记的对象，当然也可以反过来标记存货的对象，统一清除所有未标记的对象。

之所以说它是最基础的 GC 算法，是因为后续的 GC 算法大多都是在它的基础上对其缺点进行改进而得到的。它的主要缺点有两个：一是执行效率不稳定，需要清除的对象越多，执行效率越低；二是 GC 后的内存空间碎片化，可能导致之后程序申请较大内存时因为无法得到足够的连续内存空间而不得不出发另一次垃圾收集动作。

### 3.3.3 标记-复制算法

通常又被简称为复制算法。为了解决“标记-清除”面对大量可回收对象时的执行效率低的问题，1969 年 Fenichel 提出了一种称为“半区复制”（Semispace Copy）的 GC 算法，将可用内存分为大小相等的两块，每次只使用一块，当这一块的内存用完后，将还存活者的对象复制到另外一块上面，然后把之前的那块全部清空。这种算法的优点是分配内存时不用考虑有空间碎片的问题，只需要移动堆顶指针按顺序分配即可，实现简单，运行高效。其缺点也很明显，GC 时会有一些内存间复制的开下，更大的代价时可用内存缩小为了原来的一半，比较浪费空间。

现在的商用 Java 虚拟机大多采用这种算法去回收新生代，IBM 公司曾有一项专门研究对新生代“朝生夕灭”的特点做了更量化的诠释——新生代中对象有 98% 熬不过第一轮收集。因此并不需要按照 1:1 的比例来划分新生代的内存空间。

1959 年，Andrew Appel 针对具备“朝生夕灭”特点的对象，提出了一种更优化的半区复制粉黛策略，现在成为“Appel 式回收”。HotSpot 虚拟机的 Serial、ParNew 等新生代收集器均采用了这种策略来设计新生代的内存布局。具体做法是把新生代分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次分配内存只是用 Eden 和其中一块 Survivor。发生 GC 时，将 Eden 和 Survivor 中仍存活的对象一次性复制到另外一块 Survivor 上，然后直接清理掉 Eden 和之前的那块 Survivor 空间。HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8:1，即每次新生代中可用内存为整个新生代容量的 90%（Eden 的 80% 加上一个 Survivor 的 10%），这样空间浪费的情况就大大减少了。当然，为了避免 GC 后存活的对象大于 10% 的极端情况，Appel 式回收还有一个充当罕见情况的“逃生门”的安全设计