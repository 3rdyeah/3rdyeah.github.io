+++
title = '第十章 前端编译与优化.md'
date = 2023-11-09T15:56:46+08:00
draft = true
tags = ['jvm']
+++

# 第十章 前端编译与优化

## 10.2 Javac 编译器

### 10.2.1 Javac 的源码与调试

从 javac 代码的总体结构来看，编译过程大致可以分为 1 个准备过程和 3 个处理过程：

##### 1）准备过程：初始化插入式注解处理器。

##### 2）解析与填充符号表过程，包括：

- 词法、语法分析。将源码的字符流转变为标记合集，构造出抽象语法树。
- 填充符号表。产生符号地址和符号信息。

##### 3）插入式注解处理器的注解处理过程：插入式注解处理器的执行阶段。

##### 4）分析与字节码生成过程，包括：

- 标注检查。对语法的静态信息进行检查。
- 数据流及控制流分析。对程序动态运行过程进行检查。
- 解语法糖。将简化代码编写的语法糖还原为原有的形式。
- 字节码生成。将前面各个步骤所生成的信息转化为字节码。



## 10.3 Java 语法糖的味道

### 10.3.1 泛型

泛型的本质式参数化类型或者参数化多态的应用，即可以将操作的数据类型指定为方法签名中的一种特殊参数，这种参数能够在类、接口和方法的创建中，分别构成泛型类、泛型接口和泛型方法。

参数化类型：Parameterized Type

参数化多态：Parameteric Polymorphism

#### 1.Java 与 C# 的泛型

Java 的泛型实现方式叫做“类型擦除式泛型”，C# 的泛型实现方式叫做“具现化式泛型”。

类型擦除式泛型：Type Erasure Generics

具现化式泛型：Reified Generics

C# 中的泛型无论在程序源码里、编译后的中间语言表示里，还是运行其的 CLR 里都是切实存在的，它们由系统在运行期生成，由自己独立的虚方法和类型数据，例如 LIst<int> 和 List<string> 在 C# 中就是两种不同的类型。

Java 中的泛型只在程序源码中存在，在编译后的字节码文件中全部泛型都被替换为原来的裸类型（Raw Type），并且在相应的地方加入了强制转型代码，因此，对于运行期的 java 来说，ArrayList<Integer> 和 ArrayList<String> 是同一个类型。

```java
public class TypeErausreGenerics<E> {
    public void doSomething(Object item) {
        if (item instanceof E) {	// 不合法，无法对泛型进行实力判断
            ...
        }
        E newItem = new E();		// 不合法，无法使用泛型创建对象
        E[] itemArray = new E[10];	// 不合法，无法使用泛型船舰数组
    }
}
```

### 10.3.2 自动装箱、拆箱与遍历循环

